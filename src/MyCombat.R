my_aprior<-function(gamma.hat){
  m <- mean(gamma.hat,na.rm=T)
  s2 <- var(gamma.hat,na.rm = T)
  (2 * s2 + m^2)/s2
}
my_bprior<-function(gamma.hat) 
{
  m <- mean(gamma.hat,na.rm=T)
  s2 <- var(gamma.hat,na.rm = T)
  (m * s2 + m^3)/s2
}
my_it.sol<-function (sdat, g.hat, d.hat, g.bar, t2, a, b, conv = 1e-04) 
{
  n <- rowSums(!is.na(sdat))
  g.old <- g.hat
  d.old <- d.hat
  change <- 1
  count <- 0
  while (change > conv) {
    g.new <- postmean(g.hat, g.bar, n, d.old, t2)
    sum2 <- rowSums((sdat - g.new %*% t(rep(1, ncol(sdat))))^2, 
                    na.rm = TRUE)
    d.new <- postvar(sum2, n, a, b)
    change <- max(abs(g.new - g.old)/g.old, abs(d.new - d.old)/d.old,na.rm = T)
    g.old <- g.new
    d.old <- d.new
    count <- count + 1
  }
  adjust <- rbind(g.new, d.new)
  rownames(adjust) <- c("g.star", "d.star")
  adjust
}
combat<-function (dat, batch, mod = NULL, par.prior="auto", fit.method="mle",  
          mean.only = FALSE, ref.batch = NULL, BPPARAM = bpparam("SerialParam")) 
{
  if (mean.only == TRUE) {
    message("Using the 'mean only' version of ComBat")
  }
  if (length(dim(batch)) > 1) {
    return("This version of ComBat only allows one batch variable")
    stop("This version of ComBat only allows one batch variable")
  }
  batch <- as.factor(batch)
  batchmod <- model.matrix(~-1 + batch)
  if (!is.null(ref.batch)) {
    if (!(ref.batch %in% levels(batch))) {
      return("reference level ref.batch is not one of the levels of the batch variable")
      stop("reference level ref.batch is not one of the levels of the batch variable")
    }
    cat("Using batch =", ref.batch, "as a reference batch (this batch won't change)\n")
    ref <- which(levels(as.factor(batch)) == ref.batch)
    batchmod[, ref] <- 1
  }
  else {
    ref <- NULL
  }
  message("Found", nlevels(batch), "batches")
  n.batch <- nlevels(batch)
  batches <- list()
  for (i in 1:n.batch) {
    batches[[i]] <- which(batch == levels(batch)[i])
  }
  n.batches <- sapply(batches, length)
  if (any(n.batches == 1)) {
    mean.only = TRUE
    message("Note: one batch has only one sample, setting mean.only=TRUE")
  }
  n.array <- sum(n.batches)
  design <- cbind(batchmod, mod)
  check <- apply(design, 2, function(x) all(x == 1))
  if (!is.null(ref)) {
    check[ref] <- FALSE
  }
  design <- as.matrix(design[, !check])
  message("Adjusting for", ncol(design) - ncol(batchmod), 
          "covariate(s) or covariate level(s)")
  if (qr(design)$rank < ncol(design)) {
    if (ncol(design) == (n.batch + 1)) {
      return("The covariate is confounded with batch! Remove the covariate and rerun ComBat")
      stop("The covariate is confounded with batch! Remove the covariate and rerun ComBat")
    }
    if (ncol(design) > (n.batch + 1)) {
      if ((qr(design[, -c(1:n.batch)])$rank < ncol(design[, 
                                                          -c(1:n.batch)]))) {
        return("The covariates are confounded! Please remove one or more of the covariates so the design is not confounded")
        stop("The covariates are confounded! Please remove one or more of the covariates so the design is not confounded")
      }
      else {
        return("At least one covariate is confounded with batch! Please remove confounded covariates and rerun ComBat")
        stop("At least one covariate is confounded with batch! Please remove confounded covariates and rerun ComBat")
      }
    }
  }
  NAs <- any(is.na(dat))
  if (NAs) {
    message(c("Found", sum(is.na(dat)), "Missing Data Values"), 
            sep = " ")
  }
  cat("Standardizing Data across genes\n")
  if (!NAs) {
    B.hat <- solve(crossprod(design), tcrossprod(t(design), 
                                                 as.matrix(dat)))
  }
  else {
    B.hat <- apply(dat, 1, Beta.NA, design)
  }
  if (!is.null(ref.batch)) {
    grand.mean <- t(B.hat[ref, ])
  }
  else {
    grand.mean <- crossprod(n.batches/n.array, B.hat[1:n.batch, 
                                                     ])
  }
  if (!NAs) {
    if (!is.null(ref.batch)) {
      ref.dat <- dat[, batches[[ref]]]
      var.pooled <- ((ref.dat - t(design[batches[[ref]], 
                                         ] %*% B.hat))^2) %*% rep(1/n.batches[ref], n.batches[ref])
    }
    else {
      var.pooled <- ((dat - t(design %*% B.hat))^2) %*% 
        rep(1/n.array, n.array)
    }
  }
  else {
    if (!is.null(ref.batch)) {
      ref.dat <- dat[, batches[[ref]]]
      var.pooled <- rowVars(ref.dat - t(design[batches[[ref]], 
                                               ] %*% B.hat), na.rm = TRUE)
    }
    else {
      var.pooled <- rowVars(dat - t(design %*% B.hat), 
                            na.rm = TRUE)
    }
  }
  stand.mean <- t(grand.mean) %*% t(rep(1, n.array))
  if (!is.null(design)) {
    tmp <- design
    tmp[, c(1:n.batch)] <- 0
    stand.mean <- stand.mean + t(tmp %*% B.hat)
  }
  s.data <- (dat - stand.mean)/(sqrt(var.pooled) %*% t(rep(1, 
                                                           n.array)))
  message("Fitting L/S model and finding priors")
  batch.design <- design[, 1:n.batch]
  if (!NAs) {
    gamma.hat <- solve(crossprod(batch.design), tcrossprod(t(batch.design), 
                                                           as.matrix(s.data)))
  }
  else {
    gamma.hat <- apply(s.data, 1, Beta.NA, batch.design)
  }
  delta.hat <- NULL
  for (i in batches) {
    if (mean.only == TRUE) {
      delta.hat <- rbind(delta.hat, rep(1, nrow(s.data)))
    }
    else {
      delta.hat <- rbind(delta.hat, rowVars(s.data[, i], 
                                            na.rm = TRUE))
    }
  }
  gamma.bar <- rowMeans(gamma.hat)
  t2 <- rowVars(gamma.hat)
  a.prior <- apply(delta.hat, 1, my_aprior)
  b.prior <- apply(delta.hat, 1, my_bprior)
  
  ####test norm distribution
  isNorm<-function(d,bar,t2){
    tryCatch({
      f1 <- fitdist(d, "norm")
      g1 <- try(gofstat(f1))  
      })
      if("try-error" %in% class(g1)) {
      return(FALSE)
    }
    if(g1$kstest!="not rejected"){
      return(FALSE)
    }
    else return(TRUE)
  }
  ####test inverse gamma distribution
  isInverseGamma <- function(d, a, b) {
    f2 <- try(fitdist(d, "invgamma", start = list(alpha = a, beta = b)), silent = T)
    if ("try-error" %in% class(f2))
      return(FALSE)
    g2 <- try(gofstat(f2), silent = T)
    if ("try-error" %in% class(g2))
      return(FALSE)
    if (g2$kstest != "not rejected") {
      return(FALSE)
    }
    else
      return(TRUE)
  }
  switch (par.prior,
          "noparameter" = passTest<-lapply(1:n.batch,function(x)return(FALSE)),
          "parameter" = passTest<-lapply(1:n.batch,function(x)return(TRUE)),
          "auto" =   passTest<-bplapply(1:n.batch, function(i) {
            norm.test=isNorm(gamma.hat[i,],gamma.bar[i], t2[i])
            ig.test=isInverseGamma(delta.hat[i,],a.prior[i], b.prior[i])
            return(norm.test & ig.test)
          }, BPPARAM = BPPARAM)
  )
  names(passTest)<-levels(batch)
  addition_data<-list(gamma.hat=gamma.hat,delta.hat=delta.hat,passTest=passTest)
  
  gamma.star <- delta.star <- matrix(NA, nrow = n.batch, ncol = nrow(s.data))
  if (sum(passTest==TRUE)>0) {
    message("Finding parametric adjustments")
    batchNum.par<-which(passTest==TRUE)
    results <- bplapply(batchNum.par, function(i) {
      if (mean.only) {
        gamma.star <- postmean(gamma.hat[i, ], gamma.bar[i], 
                               1, 1, t2[i])
        delta.star <- rep(1, nrow(s.data))
      }
      else {
        temp <- my_it.sol(s.data[, batches[[i]]], gamma.hat[i, 
                                                         ], delta.hat[i, ], gamma.bar[i], t2[i], a.prior[i], 
                       b.prior[i])
        gamma.star <- temp[1, ]
        delta.star <- temp[2, ]
      }
      list(gamma.star = gamma.star, delta.star = delta.star)
    }, BPPARAM = BPPARAM)
    for (i in batchNum.par) {
      gamma.star[i, ] <- results[[which(batchNum.par==i)]]$gamma.star
      delta.star[i, ] <- results[[which(batchNum.par==i)]]$delta.star
    }
  }
  if (sum(passTest==FALSE)>0) {
    message("Finding nonparametric adjustments")
    batchNum.no<-which(passTest==FALSE)
    results <- bplapply(batchNum.no, function(i) {
      if (mean.only) {
        delta.hat[i, ] = 1
      }
      temp <- int.eprior(as.matrix(s.data[, batches[[i]]]), 
                         gamma.hat[i, ], delta.hat[i, ])
      list(gamma.star = temp[1, ], delta.star = temp[2, 
                                                     ])
    }, BPPARAM = BPPARAM)
    for (i in batchNum.no) {
      gamma.star[i, ] <- results[[which(batchNum.no==i)]]$gamma.star
      delta.star[i, ] <- results[[which(batchNum.no==i)]]$delta.star
    }
  }
  if (!is.null(ref.batch)) {
    gamma.star[ref, ] <- 0
    delta.star[ref, ] <- 1
  }
  message("Adjusting the Data\n")
  bayesdata <- s.data
  j <- 1
  for (i in batches) {
    bayesdata[, i] <- (bayesdata[, i] - t(batch.design[i, 
                                                       ] %*% gamma.star))/(sqrt(delta.star[j, ]) %*% t(rep(1, 
                                                                                                           n.batches[j])))
    j <- j + 1
  }
  bayesdata <- (bayesdata * (sqrt(var.pooled) %*% t(rep(1, 
                                                        n.array)))) + stand.mean
  if (!is.null(ref.batch)) {
    bayesdata[, batches[[ref]]] <- dat[, batches[[ref]]]
  }
  #cat(unlist(passTest))
  return(list(bayesdata=bayesdata,additiondata=addition_data))
}
